直接逐行往下执行很难 精准的往下一层 进入，

那么我们可以先把后端的关键入口函数 搞清楚，在入口打上断点，往上走：

后端文件的分工如下：

硬件后端抽象层。
ggml-backend-impl.h:    定义了所有硬件后端（CPU, CUDA, Metal等）必须遵守的接口规范。
ggml-backend.cpp:       实现了调用具体后端接口的通用逻辑和计算任务调度器，能将一个计算图拆分到多个硬件上执行。
ggml-backend-reg.cpp:   负责管理、注册和发现可用的硬件后端，支持静态编译和动态加载。

我们现搞清楚 上面这几个文件的 组织方式 ，就可以准确的打点了。

ggml.h / ggml.c / ggml.cpp:                 ggml 核心库。定义了张量（tensor）、计算图（cgraph）等基本数据结构，以及在其上执行的各种数学运算（如矩阵乘法、加法等）。
ggml-alloc.c:                               内存分配器。为计算图中的张量提供高效的内存管理策略，包括一个动态分配器，用于在计算过程中复用内存。

ggml-quants.c / ggml-quants.h:              量化函数库。包含了将浮点张量转换为各种低精度（如4位、8位）量化格式以及反量化的核心算法。
ggml-threading.cpp / ggml-threading.h:      线程工具。提供简单的跨平台线程同步功能（互斥锁），以保证库在多线程环境下的安全。
gguf.cpp:                                   GGUF 文件格式处理器。负责读取和写入 GGUF 格式的模型文件，解析模型的元数据和张量数据。
ggml-opt.cpp:                               优化与训练框架。在 ggml 基础上实现了模型训练所需的功能，包括数据集处理、损失函数计算、反向传播和优化器（如 AdamW）的应用。




大致的后端 架构 清楚了， 下一步和 cann 实际后端 对接上，  看看  alc 的具体初始化， 缓存管理  流管理， 究竟几个流在执行，每个流在干啥。


然后就需要理解debug 一次 ，启动起来，   这里 已经成功


然后要搞清楚  kv-cache 究竟是怎么 实现的 什么 机制  
    更加细节的 调度机制。 